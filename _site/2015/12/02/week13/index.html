<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Week 13 Subscriptions and Cursors &middot; annotatAR
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/annotatar/styles.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/annotatar/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/annotatar/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="annotatAR" href="/annotatar/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/annotatar/" title="Home">annotatAR</a>
          <small>lo-fi augmented reality for the mobile web</small>
        </h3>
      </header>

      <main>
        <article class="post">
  <h1 class="post-title">Week 13 Subscriptions and Cursors</h1>
  <time datetime="2015-12-02T00:00:00-05:00" class="post-date">02 Dec 2015</time>
  <p>Working with Meteor: automating modifications to the hashtag database.</p>

<hr />

<h4 id="streamlining-the-app">Streamlining the app</h4>

<p>Originally, the implementation of Hashtag collection additions and look-up required a number of “manual” code modifications. This week, I refactored the code to leverage the <a href="http://www.meteorpedia.com/read/Understanding_Meteor_Publish_and_Subscribe">database functionalities in Mongo / Meteor</a>. </p>

<p>Rather than publishing many versions of the Tweet database, the client-side subscription takes the relevant hashtag as an argument, and passes this to the server which then provides the appropriate publication - the tweets filtered on the appropriate hashtag. There is a fall-back defaulting to the “occupy” hashtag, if the app cannot access the geolocation of the client’s device, or if there is no hashtag paired with that location.</p>

<p>Previously, there was a separate array to track the hashtags and make a Twitter API query - however, this was inefficient. By utilizing the functionality of the Mongo <code>find()</code> command to return a cursor that can be used as a dynamically-updated array, the Hashtag collection now also functions as the basis for the Twitter REST API call. </p>

<h4 id="template-mods">Template mods</h4>

<p>I’ve also restructured the application so that Meteor appends a header HTML block with references to css and Google fonts. I based the application file structure on <a href="https://themeteorchef.com/snippets/organizing-your-meteor-project/">The Meteor Chef</a> recommendations, resulting in a more maintainable and legible code base.</p>

<h4 id="stream-vs-rest">Stream vs REST</h4>

<p>This is the major decision that still needs to be made. Currently, I’m using the Twitter REST API to request the last 20 tweets for each hashtag in the database. This approach has several limitations: </p>

<ul>
  <li>Dilution of the concept of merging two simultaneous, multi-sited events</li>
  <li>Age-til-die-off is often inappropriate - this needs to be normalized per hashtag</li>
</ul>

<p>The REST API does have a few advantages:</p>

<ul>
  <li>Predictable number of query results</li>
  <li>Static database once the app is running</li>
  <li>Ensures that tweets will be present in the AR frame, even if there isn’t a lot of recent activity on the hashtag</li>
  <li>Provides a framework for future deployment with historic tweet data (ie as part of Invisible Monument)</li>
</ul>

<p>I think the best approach is to blend the two - to make an initial REST query when the app initializes, to ensure that there is a corpus of tweets to display in the AR frame. The age-til-die-off might be normalized based on the results of the initial query. Then as the app runs, it will connect to a <a href="http://www.meteorpedia.com/read/Understanding_Meteor_Publish_and_Subscribe">multi-channel stream</a>. Tweets will be added to the database - up to 100 per hashtag. Once the limit is reached, the database will delete the oldest tweet as each new one arrives.</p>

<h4 id="next-steps">Next steps</h4>

<p>The REST API has already been implemented, so implementing the stream is not mission-critical at this time. At this time I’ve got a number of pressing issues to finalize the documentation page.</p>

<ul>
  <li>Normalizing age-til-die-off</li>
  <li>Styling the documentation page</li>
  <li>Adding a map to the documentation page </li>
  <li>Using accelerometer data to change the tweet positions</li>
  <li>Styling the tweets</li>
  <li>Deploying annotatAR on Digital Ocean</li>
</ul>


</article>


<aside class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/annotatar/2015/12/08/week14/">
            Week 14 MUP, NGINX, HTTPS
            <small><time datetime="2015-12-08T00:00:00-05:00">08 Dec 2015</time></small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/annotatar/2015/11/23/week12/">
            Week 12 Templates and Collections
            <small><time datetime="2015-11-23T00:00:00-05:00">23 Nov 2015</time></small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/annotatar/2015/11/15/week11/">
            Week 11 Routing
            <small><time datetime="2015-11-15T00:00:00-05:00">15 Nov 2015</time></small>
          </a>
        </h3>
      </li>
    
  </ul>
</aside>


      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2015-12-08T00:09:32-05:00">2015</time>. All rights reserved.
          <span class="right"><a href="/annotatar/archive" title="Archive">Archive</a></span>
        </small>
      </footer>
    </div>

  </body>
</html>
